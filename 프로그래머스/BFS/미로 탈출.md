# 프로그래머스 미로 탈출
[미로 탈출](https://school.programmers.co.kr/learn/courses/30/lessons/159993)
```java
import java.util.*;

class Solution {
    static class Point{
        int y, x;
        boolean checkP;
        Point(int y, int x, boolean checkP){
            this.y = y;
            this.x = x;
            this.checkP = checkP;
        }
    }
    static int[] dx = {1, 0, -1, 0};
    static int[] dy = {0, 1, 0, -1};
    static boolean[][] check; 
    static int[][] count;
    static int x_len, y_len;
    
    public int solution(String[] maps) {
        int answer = -1;
        x_len = maps[0].length();
        y_len = maps.length;
        count = new int[y_len][x_len];
        check = new boolean[y_len][x_len];
        for(int i = 0; i < y_len; i++ ){
            for(int j = 0; j < x_len; j++){
                if(maps[i].charAt(j) == 'S'){
                    answer = BFS1(i, j, maps);
                }
            }
        }
        if(answer == -1) return answer;
        for(int i = 0; i < y_len; i++){
            for(int j = 0; j < x_len; j++){
                if(BFS2(i, j, answer, maps) == 'L'){
                    answer = BFS2(i, j, answer, maps);
                    break;
                } 
            }
        }
         
        return answer;
    }
    
    static int BFS1(int y, int x, String[] maps){
        Queue<Point> Q = new LinkedList<>();
        Q.offer(new Point(y, x, false));
        check[y][x] = true;
        count[y][x] = 0;
        
        while(!Q.isEmpty()){
            Point p = Q.poll();
            int nowY = p.y;
            int nowX = p.x;
            if(p.checkP){
                return count[nowY][nowX];
            }
            for(int i = 0; i < 4; i++){
                int nextY = nowY + dy[i];
                int nextX = nowX + dx[i];
                if(nextY < 0 || nextY > y_len - 1 
                   || nextX < 0 || nextX > x_len - 1 ) continue;
                if(!check[nextY][nextX] && maps[nextY].charAt(nextX) == 'O'){
                    Q.offer(new Point(nextY, nextX, false));
                    check[nextY][nextX] = true;
                    count[nextY][nextX] = count[nowY][nowX] + 1;
                    System.out.println();
                }else if(!check[nextY][nextX] && maps[nextY].charAt(nextX) == 'L'){
                    Q.offer(new Point(nextY, nextX, true));
                    check[nextY][nextX] = true;
                    count[nextY][nextX] = count[nowY][nowX] + 1;
                }
                
            }
        }    
        
        return -1; 
    }
    
     static int BFS2(int y, int x, int answer, String[] maps){
        Queue<Point> Q = new LinkedList<>();
        Q.offer(new Point(y, x, false));
        check[y][x] = true;
        count[y][x] = answer;
        
        while(!Q.isEmpty()){
            Point p = Q.poll();
            System.out.print(p.checkP);
            int nowY = p.y;
            int nowX = p.x;
            if(p.checkP){
                System.out.print("지나감");
                return count[nowY][nowX];
            }
            for(int i = 0; i < 4; i++){
                int nextY = nowY + dy[i];
                int nextX = nowX + dx[i];
                if(nextY < 0 || nextY > y_len - 1 
                   || nextX < 0 || nextX > x_len - 1 ) continue;
                if(!check[nextY][nextX] && maps[nextY].charAt(nextX) == 'O'){
                    Q.offer(new Point(nextY, nextX, false));
                    check[nextY][nextX] = true;
                    count[nextY][nextX] = count[nowY][nowX] + 1;
                }else if(!check[nextY][nextX] && maps[nextY].charAt(nextX) == 'E'){
                    Q.offer(new Point(nextY, nextX, true));
                    check[nextY][nextX] = true;
                    count[nextY][nextX] = count[nowY][nowX] + 1;
                }
                
            }
        }    
        return -1; 
    }
}
```