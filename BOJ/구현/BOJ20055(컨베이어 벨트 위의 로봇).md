# 백준 20055번 컨베이어 벨트 위의 로봇
[백준 20055번](https://www.acmicpc.net/problem/20055)
```java
import java.io.*;
import java.util.*;

class Main {
    static int[] arr;
    static boolean[] isRobot;
    static int N, K;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken()); // 내구도가 0인 칸의 개수
        arr = new int[N * 2];
        isRobot = new boolean[N];
        st = new StringTokenizer(br.readLine(), " ");
        for (int i = 0; i < N * 2; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        System.out.println(solve());
    }
    
    private static int solve() {
        int count = 0;
        while (true) {
            count++;
            // 컨베이어 벨트 1칸씩 이동
            int lastIdx = arr[N * 2 - 1];
            for (int i = N * 2 - 2; i >= 0; i--) {
                arr[i + 1] = arr[i];
            }
            arr[0] = lastIdx;
            // 컨베이어 벨트를 이동해서 위에 얹혀있는 로봇도 함께 이동
            for (int i = N - 2; i >= 0; i--) {
                isRobot[i + 1] = isRobot[i];
            }
            isRobot[0] = false;
            // 로봇 이동 후 로봇이 마지막 칸에 있는지 확인
            if (isRobot[N - 1]) {
                isRobot[N - 1] = false;
            }
            
            // 이번엔 컨베이어 벨트가 움직여서가 아닌 로봇 혼자서 이동
            for (int i = N - 2; N >= 0; i--) {
                if (!isRobot[i + 1] && arr[i + 1] > 0) {
                    // 확인
                    isRobot[i] = false;
                    isRobot[i + 1] = true;
                    // 로봇이 도착한 곳 내구도 감소
                    arr[i + 1]--;
                }
            }
            // 로봇 이동 후 로봇이 마지막 칸에 있는지 확인
            if (isRobot[N - 1]) {
                isRobot[N - 1] = false;
            }
            // 첫 시작점에 로봇도 없고 내구도가 0보다 크다면 
            if(!isRobot[0] && arr[0] > 0){
                isRobot[0] = true;
                arr[0]--;
            }
            // 내구도가 0인 것을 찾는다.
            int durZeroCount = 0;
            for (int i = 0; i < 2 * N; i++) {
                if (arr[i] < 1) durZeroCount++;
            }
            if (durZeroCount >= K) break;
        }
        return count;
    }
}
```