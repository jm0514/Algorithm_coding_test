# 백준 16234번 인구 이동
[백준 16234번](https://www.acmicpc.net/problem/16234)
```java
import java.util.*;
import java.io.*;

class Main {
    static class Point {
        int x, y;
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    static int N, L, R;
    static int[][] arr;
    static boolean[][] check;
    static int[] dx = {1, 0, -1, 0};
    static int[] dy = {0, 1, 0, -1};
    static boolean isMove;
    static ArrayList<Point>;
    public static void main(String[] args) throws IOExeption {
        BufferedReader br = new BufferedReader(new InputStreaReader(System.in));
        StringTokenizer st;
        st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        arr = new int[N][N];
        L = Integer.parseInt(st.nextToken());
        R = Integer.parseInt(st.nextToken());
        
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        
        move();
    }
    
    private static void move() {
        
        while (true) {
            
            isMove = false;
            check = new boolean[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if(!check[i][j]) {
                        list = new ArrayList<>();
                        BFS(j, i);
                    }
                }
            }
            if(!isMove) break;
            
        }
    }
    
    private static void BFS(int x, int y) {
        Queue<Point> Q = new LinkedList<>();
        Q.offer(new Point(x, y));
        check[y][x] = true;
        while (!Q.isEmpty()) {
            Point p = Q.poll();
            int nowX = p.x;
            int nowY = p.y;
            for (int i = 0; i < 4; i++) {
                int nextX = dx[i] + nowX;
                int nextY = dy[i] + nowY;
                if (nextX < 0 || nextX >= N || nextY < 0 || nextY >= N) continue;
                if (!check[nextY][nextX] && Math.abs(arr[nextY][nextX] - arr[nowY][nowX]) >= L 
                        && Math.abs(arr[nextY][nextX] - arr[nowY][nowX]) <= R) {
                    isMove = true;
                    check[nextY][nextX] = true;
                    Q.offer(new Point(nextX, nextY));
                    list.add(new Point(nextX, nextY));
                }
            }
        }
        
        int sum = 0;
        for (int i = 0; i < list.size(); i++) {
            list.get(i);
        }
    }
}
```